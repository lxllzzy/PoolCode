# 项目简介
1、基于可变参模板编程和引用折叠原理，实现线程池submitTask接口，支持任意任务函数和任意参数
的传递

2、使用future类型定制submitTask提交任务的返回值

3、使用map和queue容器管理线程对象和任务

4、基于条件变量condition_variable和互斥锁mutex实现任务提交线程和任务执行线程间的通信机制

5、支持fixed和cached模式的线程池定制

# 问题说明
## 编译器问题
c++11/14编译器

为什么你会报“拷贝/赋值被删除”

Result 里有这些成员：
<ol>
<li>Any _any：Any 明确禁止拷贝（Any(const Any&)=delete; operator= = delete;），只支持移动。</li>
<li>Semaphore _sem：里面有 std::mutex / std::condition_variable，这些类型既不可拷贝也不可移动。</li>
<li>std::atomic_bool _isValid：std::atomic 也不可拷贝、不可移动</li>
</ol>

因此，Result 既不能拷贝也不能移动。如果函数写成：
<code>Result submitTask(std::shared_ptr<Task> sp);</code>



在 C++17 之前（或编译器没启用 C++17）时，返回一个按值的 Result 通常需要拷贝/移动构造，编译器就会报你看到的错误（拷贝/赋值被删除）。


在 C++17 里，引入了“强制拷贝省略（Guaranteed Copy Elision）”。当函数“按值返回一个同类型的临时对象”时，不需要存在可用的拷贝/移动构造函数，编译器直接在调用者的栈上就地构造结果对象——所以即便 Result 不可拷贝/不可移动，也能返回成功。

直接切到 C++17 编译：
g++ -std=c++17 main.cpp ThreadPool.cpp -o threadPool -pthread


这样即使 Result 不可拷贝/移动，也可以按值返回（因为会强制拷贝省略）。

或者，保持你现在项目里的接口：返回 std::shared_ptr<Result>（你当前工程就是这么写的）。这条路在任何标准下都能编过，因为只是在拷贝/移动智能指针。


额外说明

即使切到 C++17，按值返回 Result 只在“直接返回临时”的场景是保证省略的。如果把结果再放入容器、做赋值等，还是会需要移动/拷贝构造，而你的 Result 依旧不具备这些能力。

这也是线程池实现里很多人会选择用 std::future/std::promise或者返回智能指针的原因：避免对结果对象的复制/移动要求。

## 在 C++11/14

- 函数按值返回对象时，需要**拷贝/移动构造**（除非编译器选择做 NRVO/拷贝省略，但那是“可选优化”）。
- 你的 `Result` 里有 `mutex/condvar/atomic` 等**不可拷贝也不可移动**成员 ⇒ 没法拷贝/移动。
- 如果编译器**没**做 NRVO，就必须拷贝/移动 ⇒ **直接编译错误**。

> 结论：C++11/14 下，“能不能过”取决于编译器是否选择做 NRVO；一旦不做就报错，所以你卡住了。

## 在 C++17

- 引入了**强制拷贝省略（Guaranteed Copy Elision）** + prvalue 语义变化：

  - 在以下“直接返回临时”的场景中，**标准要求**不需要也不会调用拷贝/移动构造函数，**即使它们被删除也无所谓**：

    ```
    Result foo() {
        return Result(...);   // 直接在调用方的目标存储上构造
    }
    ```

  - 换句话说：**不再先构造一个临时，再拷/移动到返回值**；而是**直接在调用者的存储中构造**返回对象。

> 结论：C++17 下，这类返回写法**不依赖优化**、**不需要拷/移构造可用**，自然就编过去了。

# 这会不会“有危险”？

- **没有**。它不是“编译器偷偷优化”，而是**标准保证的语义**；就算你关掉优化选项也依然成立。
- 真正需要注意的是：**只有“直接返回临时”的那几种形态才有此保证**。一旦你把返回值拿来做赋值/放容器等，仍可能需要移动/拷贝，这时你不可拷/移动的 `Result` 还是会出问题。

# 一眼分辨哪些场景被“保证省略”

✅ 保证不需要拷/移动（C++17 起）：

```
Result make() {
  return Result(args);   // 直接构造到调用者的存储
}
```

❌ 仍可能需要移动/拷贝：

```
Result a = make();       // 初始化一般也能优化，但不属于“保证”那一条
Result b;
b = make();              // 赋值需要移动/拷贝（若未被优化掉）
std::vector<Result> v;
v.push_back(make());     // 容器场景也可能需要移动/拷贝
```

# 你可以怎么选

- 想保持“按值返回 `Result`”的接口：**用 C++17 或更新标准编译**。
- 想在所有标准下都稳妥：**返回 `std::shared_ptr` / `std::unique_ptr`**。
- 或者把 `Result` 设计成**可移动**（把 `mutex/condvar/atomic` 等放进 `std::unique_ptr`，自己写移动构造/赋值）。

# 小结

- C++11/14：拷贝省略是“可选优化”，所以你可能报错；
- C++17：这类场景变成**语言级保证**，不再需要拷/移动 ⇒ 你老师那边自然编得过。